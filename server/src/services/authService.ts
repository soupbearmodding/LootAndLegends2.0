import bcrypt from 'bcrypt';
// Import the interface and the concrete implementation
import { UserRepository, IUserRepository } from '../repositories/userRepository.js';
import { User } from '../types.js';

const SALT_ROUNDS = 10; // Store salt rounds centrally

export interface AuthServiceResult {
    success: boolean;
    message: string;
    // Update the type to reflect that the hash is omitted
    user?: Omit<User, 'passwordHash'>;
}

export class AuthService {
    // Use the interface for type annotation (Dependency Inversion)
    private userRepository: IUserRepository;

    // Accept the interface type in the constructor
    constructor(userRepository: IUserRepository) {
        this.userRepository = userRepository;
    }

    async registerUser(username: string, password: string): Promise<AuthServiceResult> {
        // Validate username uniqueness
        const existingUser = await this.userRepository.findByUsername(username);
        if (existingUser) {
            return { success: false, message: 'Username already exists.' };
        }

        // Basic password validation (can be enhanced)
        if (!password || password.length < 6) {
            return { success: false, message: 'Password must be at least 6 characters long.' };
        }

        try {
            // Hash the password
            const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);

            // Create the new user object
            const newUser: Omit<User, 'id'> = { // Omit 'id' as it's generated by the repository/DB
                username,
                passwordHash,
                characterIds: [],
            };

            // Save the user using the repository
            const createdUser = await this.userRepository.create(newUser);

            if (createdUser) {
                return { success: true, message: 'Registration successful.' };
            } else {
                // This case might indicate a repository/DB issue not throwing an error
                return { success: false, message: 'Failed to create user account.' };
            }
        } catch (error) {
            console.error('Error during user registration:', error);
            return { success: false, message: 'An internal error occurred during registration.' };
        }
    }

    async loginUser(username: string, password: string): Promise<AuthServiceResult> {
        try {
            const user = await this.userRepository.findByUsername(username);
            if (!user) {
                return { success: false, message: 'Invalid username or password.' };
            }

            const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
            if (!isPasswordValid) {
                return { success: false, message: 'Invalid username or password.' };
            }

            // Login successful, return user data (excluding hash)
            // Explicitly cast user to User type after null check
            const fullUser = user as User;

            // Access passwordHash directly first to satisfy the compiler check?
            const hash = fullUser.passwordHash; // If this line doesn't error, the type has the property.

            // Now destructure the rest, excluding the hash
            const { passwordHash, ...userWithoutPassword } = fullUser;

            // Ensure the returned user object conforms to the expected structure (without hash)
            const resultUser: Omit<User, 'passwordHash'> = userWithoutPassword;

            return { success: true, message: 'Login successful.', user: resultUser };

        } catch (error) {
            console.error('Error during user login:', error);
            return { success: false, message: 'An internal error occurred during login.' };
        }
    }
}
