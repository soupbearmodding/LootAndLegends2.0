import { Collection, UpdateFilter, ObjectId } from 'mongodb'; // Import ObjectId
import { usersCollection } from '../db.js';
import { User } from '../types.js';

// Interface describing the shape of the UserRepository
export interface IUserRepository {
    findById(id: string): Promise<User | null>;
    findByUsername(username: string): Promise<User | null>;
    // Define create method signature based on AuthService usage
    create(userData: Omit<User, 'id'>): Promise<User | null>; // Assuming create returns the created user or null
    save(user: User): Promise<void>;
    updateCharacterList(userId: string, characterId: string, action: 'add' | 'remove'): Promise<boolean>;
}


/**
 * Finds a single user by their unique ID.
 * @param id The user's UUID.
 * @returns A promise that resolves to the User object or null if not found.
 */
async function findById(id: string): Promise<User | null> {
    try {
        // Assuming the 'id' field in the DB matches the string ID used elsewhere.
        // If the DB uses _id (ObjectId), this query needs adjustment.
        // Let's assume for now the query is correct based on the 'save' function using { id: user.id }.
        // However, if findByUsername uses _id mapping, this should too for consistency if needed.
        // Convert the string ID to a MongoDB ObjectId for querying
        if (!ObjectId.isValid(id)) {
            console.warn(`UserRepository: Invalid ID format provided to findById: ${id}`);
            return null; // Invalid ID format
        }
        const objectId = new ObjectId(id);

        const userDoc = await usersCollection.findOne({ _id: objectId });
        if (!userDoc) {
            return null;
        }

        // Map the MongoDB document (_id) to the User type (id)
        const user: User = {
            id: userDoc._id.toString(), // Map _id to id
            username: userDoc.username,
            passwordHash: userDoc.passwordHash,
            characterIds: userDoc.characterIds || [],
        };
        return user;
    } catch (error) {
        console.error(`Error finding user by ID ${id}:`, error);
        throw new Error(`Database error while finding user ${id}`);
    }
}

/**
 * Finds a single user by their username.
 * @param username The user's username.
 * @returns A promise that resolves to the User object or null if not found.
 */
async function findByUsername(username: string): Promise<User | null> {
    try {
        // Ensure case-insensitive search if desired, otherwise use as is
        // const user = await usersCollection.findOne({ username: { $regex: `^${username}$`, $options: 'i' } });
        const userDoc = await usersCollection.findOne({ username: username });

        if (!userDoc) {
            return null;
        }

        // Map _id to id if necessary
        // Check if userDoc has _id and not id, and map if needed.
        // Map the MongoDB document (_id) to the User type (id)
        const user: User = {
            id: userDoc._id.toString(), // Map _id to id
            username: userDoc.username,
            passwordHash: userDoc.passwordHash,
            characterIds: userDoc.characterIds || [],
        };

        return user;
    } catch (error) {
        console.error(`Error finding user by username ${username}:`, error);
        throw new Error(`Database error while finding user ${username}`);
    }
}

/**
 * Creates a new user in the database.
 * @param userData The user data (without ID) to create.
 * @returns A promise that resolves to the newly created User object or null on failure.
 */
async function create(userData: Omit<User, 'id'>): Promise<User | null> {
    try {
        // Generate a unique ID (e.g., using UUID) - Assuming db layer or mock handles this if not MongoDB ObjectId
        // For simplicity here, let's assume an ID is generated or handled by the underlying collection logic
        // If using MongoDB, the driver often handles _id generation. If JSON, we might need explicit ID generation.
        // Let's refine this based on how `usersCollection.insertOne` behaves.
        // Assuming `insertOne` adds an `_id` or we generate `id` beforehand.
        // For now, let's assume the DB layer handles ID generation or we adapt later.

        // We need to construct the full User object, potentially generating the ID here if needed.
        // Let's assume for now the underlying layer handles ID generation upon insertion.
        const result = await usersCollection.insertOne(userData as User); // Cast needed if ID is generated by DB

        if (result.insertedId) {
             // If using MongoDB, insertedId is available. Need to fetch the created user.
             // This might be inefficient. Consider returning the ID or the full doc from the repo.
             // Let's adjust the expectation: create might just return the ID or boolean success.
             // Re-evaluating based on AuthService: it expects the *created* user.
             // So, we need to fetch it after insert if the DB doesn't return it directly.

             // Fetch the newly inserted document using the insertedId
             const createdUserDoc = await usersCollection.findOne({ _id: result.insertedId });

             if (createdUserDoc) {
                 // Map the MongoDB document (_id) to the User type (id)
                 const createdUser: User = {
                     id: createdUserDoc._id.toString(), // Map _id to id
                     username: createdUserDoc.username,
                     passwordHash: createdUserDoc.passwordHash,
                     characterIds: createdUserDoc.characterIds || [],
                 };
                 // No need to delete _id as we constructed the object explicitly

                 console.log(`UserRepository: Created user ${createdUser.username} (ID: ${createdUser.id})`);
                 return createdUser;
             } else {
                 console.error(`UserRepository: Failed to fetch user with _id ${result.insertedId} immediately after creation.`);
                 return null; // Indicate failure
             }
        } else {
            console.warn(`UserRepository: User creation for ${userData.username} did not seem to succeed (no insertedId).`);
            return null; // Indicate failure
        }
    } catch (error) {
        console.error(`Error creating user ${userData.username}:`, error);
        // Avoid throwing here, let the service handle null return
        return null;
        // throw new Error(`Database error while creating user ${userData.username}`);
    }
}


/**
 * Saves (updates/inserts) a user to the database.
 * Performs an upsert: inserts if the user ID doesn't exist, updates if it does.
 * @param user The User object to save.
 * @returns A promise that resolves when the operation is complete.
 */
async function save(user: User): Promise<void> {
     try {
        // Ensure the user object has an ID before saving
        if (!user.id) {
            throw new Error("Cannot save user without an ID.");
        }
        // When saving, we need to query by _id, converting the user.id string
        if (!ObjectId.isValid(user.id)) {
             throw new Error(`Invalid user ID format for saving: ${user.id}`);
        }
        const objectId = new ObjectId(user.id);
        // Exclude the 'id' field from the $set operation as we query by _id
        const { id, ...userDataToSet } = user;

        const result = await usersCollection.updateOne(
            { _id: objectId }, // Query by MongoDB ObjectId
            { $set: userDataToSet }, // Set data without the string 'id' field
            { upsert: true } // Keep upsert if needed, but be aware it might insert without string 'id'
        );
        // Note: If upserting, the new document might only have _id.
        // Consider if the application *needs* a separate string 'id' field stored in the DB.
        // If not, the mapping on read (findById, findByUsername) is sufficient.
        // If yes, the $set operation needs to include the string 'id' field. Let's assume mapping on read is enough for now.

        if (result.upsertedCount > 0) {
            console.log(`UserRepository: Inserted user ${user.username} (ID: ${user.id})`);
        } else if (result.modifiedCount > 0) {
             console.log(`UserRepository: Updated user ${user.username} (ID: ${user.id})`);
        }
    } catch (error) {
        console.error(`Error saving user ${user.id}:`, error);
        throw new Error(`Database error while saving user ${user.id}`);
    }
}

/**
 * Adds or removes a character ID from a user's characterIds array.
 * @param userId The ID of the user to update.
 * @param characterId The ID of the character to add or remove.
 * @param action 'add' to push the ID, 'remove' to pull the ID.
 * @returns A promise that resolves to true if the update was successful, false otherwise.
 */
async function updateCharacterList(userId: string, characterId: string, action: 'add' | 'remove'): Promise<boolean> {
    try {
        let updateOperation: UpdateFilter<User>;
        if (action === 'add') {
            updateOperation = { $addToSet: { characterIds: characterId } }; // Use $addToSet to prevent duplicates
        } else if (action === 'remove') {
            updateOperation = { $pull: { characterIds: characterId } };
        } else {
            console.error(`Invalid action specified for updateCharacterList: ${action}`);
            return false;
        }

        // Also update this query to use ObjectId
        if (!ObjectId.isValid(userId)) {
            console.error(`Invalid user ID format for updateCharacterList: ${userId}`);
            return false;
        }
        const userObjectId = new ObjectId(userId);

        const result = await usersCollection.updateOne(
            { _id: userObjectId }, // Query by ObjectId
            updateOperation
        );

        if (result.modifiedCount === 1) {
            console.log(`UserRepository: ${action === 'add' ? 'Added' : 'Removed'} character ${characterId} ${action === 'add' ? 'to' : 'from'} user ${userId}`);
            return true;
        } else if (result.matchedCount === 1) {
             console.log(`UserRepository: User ${userId} found, but character list update for ${characterId} (${action}) resulted in no change.`);
             // This can happen if adding an existing ID with $addToSet, or removing a non-existent ID with $pull
             return true; // Still considered successful as the state is correct
        } else {
            console.warn(`UserRepository: User ${userId} not found for character list update.`);
            return false;
        }
    } catch (error) {
        console.error(`Error updating character list for user ${userId}:`, error);
        throw new Error(`Database error while updating character list for user ${userId}`);
    }
}


// Export the repository functions conforming to the interface
export const UserRepository: IUserRepository = {
    findById,
    findByUsername,
    create, // Add create method
    save,
    updateCharacterList
};
